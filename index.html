<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fishing Net vs Fishing Line</title>
<style>
  body {
    font-family: sans-serif;
    margin: 20px;
  }
  .controls {
    margin-bottom: 10px;
  }
  .container {
    display: flex;
    gap: 40px;
  }
  .panel {
    text-align: center;
  }
  svg {
    border: 1px solid #ccc;
    background: #fafafa;
  }
  .center {
    fill: steelblue;
  }
  .point {
    cursor: pointer;
  }
  .point.in-range {
    fill: green !important;
  }
  .radius {
    fill: none;
    stroke: steelblue;
    stroke-dasharray: 5,5;
    stroke-width: 2;
  }
  .ring {
    fill: none;
    stroke: #ccc;
    stroke-dasharray: 2,4;
    stroke-width: 1;
  }
  .link {
    stroke-width: 1.5;
    stroke: steelblue;
  }
  .label {
    font-weight: bold;
    margin-bottom: 6px;
  }
</style>
</head>
<body>

<h2>Fishing Net vs Fishing Line</h2>

<div class="controls">
  <label>
    X (%):
    <input type="range" id="slider" min="0" max="100" value="0">
    <span id="xval">0</span>
  </label>
  &nbsp;&nbsp;
  <label><input type="checkbox" id="equalAngle"> Even angular spacing</label>
  &nbsp;&nbsp;
  <label><input type="checkbox" id="radialLock" checked> Radial-only drag</label>
  <br><br>
  <label><input type="checkbox" id="colorPoints"> Random colored points</label>
  &nbsp;&nbsp;
  <label><input type="checkbox" id="animateLinks"> Animate top-X links</label>
</div>

<div class="container">
  <div class="panel">
    <div class="label">Net</div>
    <svg id="visA" width="400" height="400"></svg>
  </div>
  <div class="panel">
    <div class="label">Line</div>
    <svg id="visB" width="400" height="400"></svg>
  </div>
</div>

<script>
const width = 400;
const height = 400;
const center = { x: width / 2, y: height / 2 };
const maxRadius = 180;

let points = [];
let draggingPoint = null;
let spacingInitialized = false;
let animating = false;

const slider = document.getElementById("slider");
const xval = document.getElementById("xval");
const equalAngleCheckbox = document.getElementById("equalAngle");
const radialLockCheckbox = document.getElementById("radialLock");
const colorCheckbox = document.getElementById("colorPoints");
const animateLinksCheckbox = document.getElementById("animateLinks");

const svgA = document.getElementById("visA");
const svgB = document.getElementById("visB");

function distance(p) {
  return Math.hypot(p.x - center.x, p.y - center.y);
}

function angle(p) {
  return Math.atan2(p.y - center.y, p.x - center.x);
}

function ease(t) {
  return t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
}

/* ---------- Equal-angle logic ---------- */

function initializeEqualAngles() {
  const n = points.length;
  if (n < 2) return;

  points.forEach(p => p.theta0 = angle(p));
  const ordered = [...points].sort((a,b) => a.theta0 - b.theta0);

  ordered.forEach((p,i) => {
    p.thetaFixed = (2*Math.PI*i)/n;
  });

  spacingInitialized = true;
}

function animateToTargets(targets, duration=500) {
  animating = true;
  const start = performance.now();
  const starts = points.map(p => ({x:p.x, y:p.y}));

  function frame(now) {
    const t = Math.min(1, (now-start)/duration);
    const e = ease(t);

    points.forEach((p,i) => {
      p.x = starts[i].x + (targets[i].x - starts[i].x)*e;
      p.y = starts[i].y + (targets[i].y - starts[i].y)*e;
    });

    render(false);
    if (t < 1) requestAnimationFrame(frame);
    else { animating = false; render(); }
  }
  requestAnimationFrame(frame);
}

/* ---------- Rendering ---------- */

function render(applySpacing=true) {
  const x = +slider.value;
  xval.textContent = x;

  svgA.innerHTML = "";
  svgB.innerHTML = "";

  if (equalAngleCheckbox.checked && spacingInitialized && applySpacing) {
    points.forEach(p => {
      const r = distance(p);
      p.x = center.x + r*Math.cos(p.thetaFixed);
      p.y = center.y + r*Math.sin(p.thetaFixed);
    });
  }

  // Rings
  for (let i=10;i<=100;i+=10) {
    const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
    ring.setAttribute("cx",center.x);
    ring.setAttribute("cy",center.y);
    ring.setAttribute("r",maxRadius*i/100);
    ring.setAttribute("class","ring");
    svgA.appendChild(ring);
  }

  // Centers
  [svgA,svgB].forEach(svg=>{
    const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx",center.x);
    c.setAttribute("cy",center.y);
    c.setAttribute("r",6);
    c.setAttribute("class","center");
    svg.appendChild(c);
  });

  // Radius
  const rad=(maxRadius*x)/100;
  const rc=document.createElementNS("http://www.w3.org/2000/svg","circle");
  rc.setAttribute("cx",center.x);
  rc.setAttribute("cy",center.y);
  rc.setAttribute("r",rad);
  rc.setAttribute("class","radius");
  svgA.appendChild(rc);

  points.forEach(p=>{
    svgA.appendChild(makePoint(p, distance(p)<=rad));
  });

  const sorted=[...points].sort((a,b)=>distance(a)-distance(b));
  const count=Math.round(sorted.length*x/100);
  const selected=sorted.slice(0,count);

  if (animateLinksCheckbox.checked) {
    selected.forEach((p,i)=>{
      setTimeout(()=>drawLink(p), i*80);
    });
  } else {
    selected.forEach(drawLink);
  }

  points.forEach(p=>{
    svgB.appendChild(makePoint(p, selected.includes(p)));
  });
}

function drawLink(p) {
  const l=document.createElementNS("http://www.w3.org/2000/svg","line");
  l.setAttribute("x1",center.x);
  l.setAttribute("y1",center.y);
  l.setAttribute("x2",p.x);
  l.setAttribute("y2",p.y);
  l.setAttribute("class","link");
  svgB.appendChild(l);
}

function makePoint(p,highlighted) {
  const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
  c.setAttribute("cx",p.x);
  c.setAttribute("cy",p.y);
  c.setAttribute("r",6);
  c.setAttribute("class","point"+(highlighted?" in-range":""));
  c.setAttribute("fill", highlighted ? "green" :
    (colorCheckbox.checked ? p.color : "black"));
  c.onmousedown=()=>draggingPoint=p;
  return c;
}

/* ---------- Interaction ---------- */

function addPoint(evt) {
  const rect=evt.target.getBoundingClientRect();
  points.push({
    x:evt.clientX-rect.left,
    y:evt.clientY-rect.top,
    color:`hsl(${Math.random()*360},70%,45%)`
  });
  spacingInitialized=false;
  render();
}

[svgA,svgB].forEach(svg=>svg.addEventListener("click",addPoint));

document.addEventListener("mousemove",e=>{
  if(!draggingPoint||animating)return;
  const rect=svgA.getBoundingClientRect();
  const mx=e.clientX-rect.left;
  const my=e.clientY-rect.top;

  if(equalAngleCheckbox.checked && radialLockCheckbox.checked){
    const r=Math.hypot(mx-center.x,my-center.y);
    const t=draggingPoint.thetaFixed;
    draggingPoint.x=center.x+r*Math.cos(t);
    draggingPoint.y=center.y+r*Math.sin(t);
  } else {
    draggingPoint.x=Math.max(0,Math.min(width,mx));
    draggingPoint.y=Math.max(0,Math.min(height,my));
  }
  render();
});

document.addEventListener("mouseup",()=>draggingPoint=null);
slider.addEventListener("input",render);

equalAngleCheckbox.addEventListener("change",()=>{
  if(equalAngleCheckbox.checked){
    initializeEqualAngles();
    const targets=points.map(p=>{
      const r=distance(p);
      return {
        x:center.x+r*Math.cos(p.thetaFixed),
        y:center.y+r*Math.sin(p.thetaFixed)
      };
    });
    animateToTargets(targets);
  } else {
    spacingInitialized=false;
    render();
  }
});

[colorCheckbox, animateLinksCheckbox, radialLockCheckbox]
  .forEach(cb=>cb.addEventListener("change",render));

render();
</script>

</body>
</html>
